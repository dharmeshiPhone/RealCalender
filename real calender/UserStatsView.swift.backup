// MARK: - Proper Gold Ball Component
struct ProperGoldBall: View {
    let ballId: String
    let isVisible: Bool
    let startPosition: CGPoint
    let targetPosition: CGPoint
    let scrollBounds: CGRect
    let startDelay: TimeInterval
    
    @State private var ballPosition: CGPoint = .zero
    @State private var ballOpacity: Double = 0.0
    @State private var ballScale: Double = 0.0
    @State private var animationStarted: Bool = false
    
    var body: some View {
        ZStack {
            if animationStarted {
                // Outer glow
                Circle()
                    .fill(
                        RadialGradient(
                            colors: [.yellow.opacity(0.4 * ballOpacity), .clear],
                            center: .center,
                            startRadius: 10,
                            endRadius: 50
                        )
                    )
                    .frame(width: 80, height: 80)
                    .opacity(ballOpacity)
                
                // Main gold ball
                Circle()
                    .fill(
                        RadialGradient(
                            colors: [
                                .white,
                                Color(red: 1.0, green: 0.85, blue: 0.2),
                                Color(red: 1.0, green: 0.65, blue: 0.0),
                                Color(red: 0.8, green: 0.5, blue: 0.0)
                            ],
                            center: UnitPoint(x: 0.3, y: 0.3),
                            startRadius: 2,
                            endRadius: 20
                        )
                    )
                    .frame(width: 35, height: 35)
                    .shadow(color: .yellow.opacity(0.8 * ballOpacity), radius: 15)
                    .shadow(color: .orange.opacity(0.6 * ballOpacity), radius: 25)
                    .opacity(ballOpacity)
                    .scaleEffect(ballScale)
                
                // Sparkle effect
                if ballOpacity > 0.3 {
                    Image(systemName: "sparkles")
                        .foregroundColor(.white)
                        .font(.system(size: 12, weight: .bold))
                        .opacity(ballOpacity)
                        .shadow(color: .white, radius: 3)
                        .scaleEffect(ballScale)
                }
            }
        }
        .position(animationStarted ? ballPosition : .zero)
        .onChange(of: isVisible) { oldValue, newValue in
            if newValue && !animationStarted {
                startProperAnimation()
            } else if !newValue {
                resetAnimation()
            }
        }
        .onAppear {
            if isVisible && !animationStarted {
                startProperAnimation()
            }
        }
    }
    
    private func startProperAnimation() {
        guard targetPosition != .zero else { 
            print("ðŸ”´ \(ballId): Target position is zero, skipping animation")
            return 
        }
        
        guard startPosition != .zero else { 
            print("ðŸ”´ \(ballId): Start position is zero, using fallback position")
            // Fallback to top center if start position is not set
            ballPosition = CGPoint(x: UIScreen.main.bounds.width / 2, y: 150)
        }
        
        print("ðŸš€ \(ballId): Starting animation from \(startPosition) to \(targetPosition)")
        animationStarted = true
        
        DispatchQueue.main.asyncAfter(deadline: .now() + startDelay) {
            // Start from the chart's center position
            ballPosition = startPosition != .zero ? startPosition : CGPoint(x: UIScreen.main.bounds.width / 2, y: 150)
            print("ðŸš€ \(ballId): Set initial position: \(ballPosition)")
            
            // Fade in and scale up
            withAnimation(.easeOut(duration: 0.5)) {
                ballOpacity = 1.0
                ballScale = 1.0
            }
            
            // Move to target
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                print("ðŸš€ \(ballId): Moving to target: \(targetPosition)")
                withAnimation(.easeInOut(duration: 1.5)) {
                    ballPosition = targetPosition
                }
            }
            
            // Fade out at target
            DispatchQueue.main.asyncAfter(deadline: .now() + 1.8) {
                withAnimation(.easeOut(duration: 0.8)) {
                    ballOpacity = 0.0
                    ballScale = 0.8
                }
            }
            
            // Reset
            DispatchQueue.main.asyncAfter(deadline: .now() + 3.0) {
                resetAnimation()
            }
        }
    }
    
    private func resetAnimation() {
        print("ðŸ”„ \(ballId): Resetting animation")
        animationStarted = false
        ballOpacity = 0.0
        ballScale = 0.0
        ballPosition = .zero
    }
}

// Existing code...